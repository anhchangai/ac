There are N spots for fishing in the fishing center.
The center has 3 gates, and a number of customers standing before each gate.
 
To avoid disorder, the customers must enter the center follow these rules :
 1. Only one Gate is open at a time, and it will be closed after all customers of that gate entered.
 2. When open a gate, the customers stand before that gate will enter one by one, and go to the closest & empty spot from their position.
	- The distance from a gate to the spot right above it is 1m
	- Whenever a customer goes further one spot (to left or right), it takes additionally 1m further.
	- Ex : The distance from Gate 1 to spot 4 is 1m, and to spot 3, 5 is 2m
 3. If there are 2 two spots that closest to a customer, he can choose any one of them (you should consider this case)
4. After all customers enter the gate, choose the next gate to open and proceed same as above

You should find a way so that the sum of the moving distance of all customers is minimum and print out that sum.
Ex) In above figure :
- The number of fishing spots : 10
- Gate 1 : location is 4, number of waiting customer is 5
- Gate 2 : location is 6, number of waiting customer is 2
- Gate 3 : location is 10, number of waiting customer is 2

Case 1) We open the gate by the order : Gate 1 > Gate 2 > Gate 3
 
 
 
For this case, the sum of moving distance is : 3+2+1+2+3+2+3+2+1 = 19

Case 2) We open the gate by the order : Gate 2 > Gate 1 > Gate 3
When open Gate 3, the 1st customer will go to spot 6, the second one can go to spot 5 or 7
 OR  
Case 2-1)
 
In this case, the sum is : 4+3+2+1+2+1+4+2+1 = 20

Case 2-2)
 
In this case, the sum is : 4+3+2+1+2+1+2+2+1 = 18

[Input]
- The first line given the number of test case T (T <= 50)
- For each test case:
	+ The first line given the number of spots N (10 <= N <= 60)
	+ The next three lines give the information of 3 gates :
		> Gate's position P ( 1 <= P <= N)
		> The number of customers standing before that gate C ( 1 <= C <= 20 )

[Output]
The minimum moving distance of all customers
Case #1
18
Case #2
25
Case #3
57
Case #4
86
Case #5
339



#include <iostream>

using namespace std ; 
int ans, n, d;
int Gate[2][4];
int visit[100];
int select[2][4];
int V[4];
void Day(int x, int y) 
{
		// TODO Auto-generated method stub
		int k=0;
		int u =Gate[0][x], v;
		if ( visit[u] == 0)
			{
				visit[u] =1;
				k++;
				d++;
			}
		while (k < Gate[1][x] && y == 1)
		{
			u--;
			if (u >=1 && k < Gate[1][x] && visit[u] == 0)
			{
				visit[u] =1;
				k++;
				d = d+ Gate[0][x] -u +1;
			}
			
			v = 2*Gate[0][x] - u;

			if (v <= n && k < Gate[1][x] && visit[v] == 0)
			{
				visit[v] =1;
				k++;
				d = d+ v - Gate[0][x] +1;
			}
		}

		while (k < Gate[1][x] && y == 2)
		{
			u++;
			if (u <= n && k < Gate[1][x] && visit[u] == 0)
			{
				visit[u] =1;
				k++;
				d = d+ u - Gate[0][x] +1;
			}
			
			v = 2*Gate[0][x] - u;

			if (v >= 1 && k < Gate[1][x] && visit[v] == 0)
			{
				visit[v] =1;
				k++;
				d = d+ Gate[0][x] -v +1;
			}
		}
	}
void backtrack(int x) 
{

		if (x > 3)
		{
			d =0;
			for(int i =1; i<=n; i++) visit[i] =0;
			for(int i =1; i<=3; i++)
			{
				Day(select[0][i], select[1][i]);
			}
			if (d < ans) ans=d;
		}
		else
		{
			for (int i = 1; i<=3; i++)
				if (V[i] ==0)
				{
					V[i] =1;
					select[0][x] =i;
					select[1][x] = 1;
					backtrack(x+1);
					select[1][x] = 2;
					backtrack(x+1);
					V[i] =0;
				}
		}
	}
int main()
{
	freopen("input.txt" , "r" , stdin) ; 
	int T ; 
	cin >> T ; 
	for(int tc = 1 ; tc <= T ; tc ++)
	{
		ans = 9999 ; 
		d = 0 ; 
		cin >> n ; 
		for (int i = 1; i <= 3; i++) {
				cin >> Gate[0][i] >> Gate[1][i] ;
			}
			backtrack(1);
			cout << ans  ;
	}

	return 0 ; 
}

1
10
4 5 
6 2
10 2

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

using namespace std;
int n; 
int Gate[4][2];
int vs[4]; 
int tt[4];
int vsC[100];
int vsCuoi; 
int d = 0; 
int kq; 
int go(int gate1 , int vsCuoi)
{
	int t = 1;
	int gate = Gate[gate1][0];
	d = Gate[gate1][1]; 
	d--; 
	vsC[gate] = 1;
	int l = gate - 1; 
	int r = gate + 1; 
	while (l >= 1 && r <= n && d > 1)
	{
		if (!vsC[l] && !vsC[r])
		{
			t += 2 * (gate - l + 1);
			d -= 2;
			vsC[l] = 1;
			vsC[r] = 1;
		}
		l--; 
		r++; 
	}

	while (l == 0 && d > 0 )
	{
		if (!vsC[r])
		{
			d--;
			t += (r - gate);
			vsC[r] = 1; 
		}
		r++;
	}

	while (r == n && d > 0)
	{
		if (!vsC[l])
		{
			d--;
			t += (gate - l);
			vsC[l] = 1; 
		}
		l--;
	}
	 
	if (vsCuoi == 1 && d == 1)
	{
		d--;
		t += (gate - l);
		vsC[l] = 1; 
	}
	else if (vsCuoi == 1 && d == 1)
	{
		d--;
		t += (r - gate);
		vsC[r] = 1;
	}
	return t; 
}
void backtrack(int x)
{
	if (x == 4)
	{
		kq = go(tt[1] ,vsCuoi);
		kq += go(tt[2], vsCuoi); 
		
		return; 
	}
	for (int i = 1; i <= 3; i++)
	{
		if (!vs[i])
		{
			tt[i] = x; 
			vs[i] = 1; 
			vsCuoi = 1; 
			backtrack(x + 1);
			vsCuoi = 2; 
			backtrack(x + 1); 
			vs[i] = 0; 
		}
	}
}
int main()
{
	freopen("input.txt", "r", stdin);
	int T;
	cin >> T;
	for (int tc = 1; tc <= T; tc++)
	{
		cin >> n;
		kq = 0; 
		for (int i = 1; i <= 3; i++) {
			cin >> Gate[i][0] >> Gate[i][1];
		}
		backtrack(1);
	}

	return 0;
}
